\section{Model}
  \subsection{Notation}
    \begin{itemize}
      \item We denote the set of all probability distributions on set $A$ as
      $\mathcal{D\left(A\right)}$.
      \item We denote the powerset of a set $A$ with $2^A$.
      \item $a \Vert b$ denotes the concatenation of $a$ and $b$.
    \end{itemize}

  \subsection{Properties of Post Voting Systems}
    A post voting system has the objective to arrange the posts according to the
    preferences of the participants. The ideal order is defined based on the
    likeability matrix for the posts.

    \begin{definition}[Post]
      Let $\playerlen \in \mathbb{N}^*$. A post is defined as $\post = \left(i,
      \like\right)$, with $i \in \left[\playerlen\right], \like \in \left[0,
      1\right]^\playerlen$.
      \begin{itemize}
        \item \textbf{Author.} The first element of a post is the index of its
        creator, $i$.

        \item \textbf{Likeability.} The likeability of a post is defined as
        $\like \in \left[0, 1\right]^\playerlen$.
      \end{itemize}
      Let $\postlen \in \mathbb{N}^*$ the number of posts. Then $\forall j \in
      \left[\postlen\right],$ let $\mathrm{creator}_j \in
      \left[\playerlen\right], \like_j \in \left[0, 1\right]^\playerlen$ and
      $\post_j = \left(\mathrm{creator}_j, \like_j\right)$. The set of all posts
      is $\postlist = \bigcup\limits_{j=1}^\postlen \left\{\post_j\right\}$.
    \end{definition}

    \begin{definition}[Post score]
      Let post $\post = \left(m, \like\right)$. We define the \emph{score} of
      $\post$ as $\mathrm{sc}\left(\post\right) = \sum\limits_{i = 1}^\playerlen
      \like_i$.
    \end{definition}
    The score of a post is a single number that represents its overall worth to
    the community. By using simple summation, we assume that the opinions of all
    players have the same weight. In an ordered list of posts where higher posts
    are more visible, the ``common interest'' would require that a post with
    higher score appear before another post with a lower score.

    \begin{definition}[$t$-Ideal Post Order]
      Let $\postlist$ a list of posts. We say that $\postlist$ is in
      $t$-\emph{ideal order} and that the property
      $\textsc{Ideal}^{t}\left(\postlist\right)$ holds if
      \begin{equation*}
        \forall i < j \in \left|t\right|,
        \mathrm{sc}\left(\postlist\left[i\right]\right) \geq
        \mathrm{sc}\left(\postlist\left[j\right]\right) \enspace.
      \end{equation*}
    \end{definition}

    \begin{definition}[Post-Voting System]
      A tuple $\pvs = \left(\gfunc, \honeststr\right)$ of two ITMs, parametrized
      by \textsc{Init}, \textsc{Aux}, \textsc{HandleVote} and \textsc{Vote}. The
      two ITMs have to implement the following API:

      $\gfunc$ is a global functionality that accepts two messages:
      \texttt{read}, which responds with the current list of posts and
      \texttt{vote}, which can take various arguments and can do whatever the
      functionality wants. Eventually, the functionality sends a message
      (\texttt{output}, $\postlist$) to $\env$ and halts.\footnote{Alternatively
      $\env$ decides when to stop, but seems dirtier}

      $\honeststr$ is a protocol that sends \texttt{read} and \texttt{vote}
      messages to $\gfunc$ whenever activated by $\env$.
    \end{definition}

    \begin{algorithm}[H]
      \caption{$\gfunc\left(\textsc{Init}^{\gfuncname}, \textsc{Aux},
      \textsc{HandleVote}\right)\left(\postlist, \mathrm{initArgs}\right)$}
      \label{alg:gfunc}
      \begin{algorithmic}[1]
        \State Initialization:
        \Indent
          \State $\forall i \in |\postlist|,$ Parse $\postlist[i]$ as
          $\left(\mathrm{creator}_i, \like_i\right)$
          \State Assert($\forall i \neq j \in |\postlist|, |\like_i| =
          |\like_j|$)
          \State $\playerlen \gets |\like_1|$
          \State $\playerlist \gets \emptyset$
          \State $\textsc{Init}^{\gfuncname}\left(\mathrm{initArgs}\right)$
        \EndIndent
        \State
        \State Upon receiving (\texttt{read}) from $\player_{\pid}$:
        \Indent
          \State $\mathrm{aux} \gets \textsc{Aux}\left(\player_{\pid}\right)$
          \State Send (\texttt{posts}, $\postlist$, aux) to $\player_{\pid}$
        \EndIndent
        \State
        \State Upon receiving (\texttt{vote}, ballot) from
        $\player_{\mathrm{pid}}$:
         \Indent
           \State $\playerlist \gets \playerlist \cup \player_{\mathrm{pid}}$
           \If{$|\playerlist| > \playerlen$}
             \State Abort
           \EndIf
           \State \textsc{HandleVote}(ballot)
         \EndIndent
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
      \caption{$\honeststr\left(\textsc{Init}^{\honest},
      \textsc{Vote}\right)\left(\mathrm{initArgs}\right)$}
      \label{alg:honest}
      \begin{algorithmic}[1]
        \State Initialization:
        \Indent
          \State $\textsc{Init}^{\honest}\left(\mathrm{initArgs}\right)$
        \EndIndent
        \State
        \State Upon receiving (\texttt{activate}) from $\env$:
        \Indent
          \State Send (\texttt{read}) to $\gfunc$
          \State Wait for response (\texttt{posts}, $\postlist$, aux)
          \State $\mathrm{ballot} \gets \textsc{Vote}\left(\postlist,
          \mathrm{aux}\right)$
          \State Send (\texttt{vote}, ballot) to $\gfunc$
        \EndIndent
      \end{algorithmic}
    \end{algorithm}

    \begin{definition}[$t$-convergence under honesty]
      We say that a post-voting system $\pvs = \left(\gfunc, \honeststr\right)$
      $t$-\emph{converges under honesty} if, for every valid input
      $\postlist$, for every $\env$ and given that all protocols execute
      $\honeststr$, eventually $\gfunc$ sends a single message (\texttt{output},
      $\postlist$) to $\env$ such that $\textsc{Ideal}^t\left(\postlist\right)$
      holds.
    \end{definition}

    \begin{definition}[Steem system]
      The Steem system is the post voting system $\pvs$ with parameters
      $\stpowvec \in {\mathbb{N}^*}^N, R \in \mathbb{N}^*, a, b, c \in
      \mathbb{R}_{+}, \attspan \in \mathbb{N}^*$ and the following parametrizing
      procedures:
    \end{definition}

    \begin{algorithm}[H]
      \caption{$\textsc{Init}^{\gfunc}\left(\stpowvec, \rounds,
      a, b, c\right)$}
      \label{alg:steem:init:gfunc}
      \begin{algorithmic}[1]
        \State Store input parameters as constants
        \State $\round \gets 1$
        \State $\mathrm{lastVoted} \gets \underbrace{\left(0, \dots, 0\right)}_{N}$
        \State $\votpowvec \gets \underbrace{\left(1, \dots, 1\right)}_{N}$
        \State $\mathrm{scores} \gets \underbrace{\left(0, \dots,
        0\right)}_{|\postlist|}$
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
      \caption{$\textsc{Init}^{\honest}\left(\stpowvec, \attspan, \pid,
      \rounds, a, b, c\right)$}
      \label{alg:steem:init:honest}
      \begin{algorithmic}[1]
        \State Store input parameters as constants
        \State $\mathrm{votedPosts} \gets \emptyset$
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
      \caption{\textsc{Aux}}
      \label{alg:steem:aux}
      \begin{algorithmic}[1]
        \State \Return \Comment{TODO: DISCUSS: Maybe should send votes?}
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
      \caption{$\textsc{HandleVote}\left(\mathrm{ballot},
      \player_{\pid}\right)$}
      \label{alg:steem:handlevote}
      \begin{algorithmic}[1]
        \If{$\mathrm{lastVoted}_{\pid} \neq \round$} \Comment{One vote per
        player per round}
          \State $\votpowvec_{\pid} \gets \max{\lbrace \votpowvec_{\pid} + c
          \cdot \left(\round - \mathrm{lastVoted}_{\pid}\right), 1 \rbrace}$
          \If{$\mathrm{ballot} \neq \mathbf{null}$}
            \State Parse ballot as $\left(\post, \mathrm{weight}\right)$
            \State $\mathrm{score} \gets a \cdot \votpowvec_{\pid} \cdot
            \stpowvec_{\pid} \cdot \mathrm{weight} + b$
            \State $\votpowvec_{\pid} \gets \votpowvec_{\pid} - \left(a \cdot
            \votpowvec_{\pid} \cdot \mathrm{weight} + b\right)$
            \State $\mathrm{scores}_\post \gets \mathrm{scores}_\post +
            \mathrm{score}$
          \EndIf
          \State $\mathrm{lastVoted}_{\pid} \gets \round$
        \EndIf
        \If{$\forall i \in \left[N\right] \mathrm{lastVoted}_i = \round$}
        \Comment{round over}
          \State $\postlist \gets \textsc{Order}\left(\postlist,
          \mathrm{scores}\right)$ \Comment{order posts by votes}
          \If{$\round = \rounds$}
            \State Send $\left(\mathtt{output}, \postlist\right)$ to $\env$
            \State Halt
          \Else
            \State $\round \gets \round + 1$
          \EndIf
        \EndIf
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
      \caption{$\textsc{Vote}\left(\postlist\right)$}
      \label{alg:steem:vote}
      \begin{algorithmic}[1]
        \If{$\textsc{VoteThisRound}\left(\round, \rounds\right) = \mathrm{yes}$}
          \State TODO: DISCUSS NOTATION: add attSpan, votedPosts to inputs?
          \State CONT: but complex for $\honeststr$
          \State $\mathrm{top} \gets \textsc{ChooseTopPosts}\left(\attspan,
          \postlist, \mathrm{votedPosts}\right)$
          \State $p \gets \argmax\limits_{\left(i, l\right) \in
          \mathrm{top}}{\lbrace l \rbrace}$
          \State $\mathrm{votedPosts} \gets \mathrm{votedPosts} \: \cup p$
          \State \Return $\left(p, l_{\pid}\right)$
        \Else
          \State \Return \textbf{null}
        \EndIf
        \State
        \Function{ChooseTopPosts}{$\attspan, \postlist, \mathrm{votedPosts}$}
          \State $\result \gets \emptyset$
          \State $\mathrm{idx} \gets 1$
          \While{$|\result| < \attspan \And \mathrm{idx} \leq |\postlist|$}
            \If{$\postlist\left[\mathrm{idx}\right] \notin \mathrm{votedPosts}$}
            \Comment{One vote per post per player}
              \State $\result \gets \result \cup \lbrace
              \postlist\left[\mathrm{idx}\right] \rbrace$
            \EndIf
            \State $\mathrm{idx} \gets \mathrm{idx} + 1$
          \EndWhile
          \State \Return $\result$
        \EndFunction
        \State
        \Function{VoteThisRound}{$\round, \rounds$}
          \State TODO
        \EndFunction
      \end{algorithmic}
    \end{algorithm}

    \begin{theorem}
      The Steem system $t$-converges under honesty, assuming the following
      conditions on $\stpowvec, R, a, b, c, \attspan$: TODO: continue
    \end{theorem}

    The above result is tight.
    If the conditions are violated the above theorem is not true.

  \subsection{Steem Execution}
    \begin{algorithm}
      \caption{Each player creates one post}
      \label{alg:postGen}
      \begin{algorithmic}[1]
      \Function{GeneratePosts}{$\mathcal{U}$}
        \State $\mathcal{P} = \emptyset$ \Comment{List of posts}
        \For{$u_i \in \mathcal{U}$}
           \State $l \xleftarrow{r} L_i$
             \Comment{Get likeability of posts}
           \State $\mathcal{P} \leftarrow \mathcal{P} \Vert \left(i, l, 0\right)$
             \Comment{Add post to list of Posts}
        \EndFor
        \State $\mathcal{P} \leftarrow \textsc{Shuffle}(\mathcal{P})$
          \Comment{Shuffle posts to a random order}
        \State \Return $\mathcal{P}$
      \EndFunction
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}%[H]
      \caption{Player votes for best of $k$ posts}
      \label{alg:vote}
      \begin{algorithmic}[1]
      \Function{Vote}{$u_i, \mathcal{P}$}
        \Switch{$S_i$}
          \Case{$honest$}
            \State $p_j \leftarrow \argmax\limits_{p \in \mathcal{P}_{1 ..
              k}}{\lbrace l_{i, p}\rbrace}$
            \State Parse $p_j$ as $\left(m, l_p, v\right)$
            \State $v' \leftarrow v + a \cdot \mathrm{VP}_i \cdot l_{i, p} \cdot
            \mathrm{SP}_i + b$
            \State $\mathrm{VP}_i \gets \mathrm{VP}_i - \left(a \cdot
            \mathrm{VP}_i \cdot l_{i, p} + b\right)$
            \State $\mathcal{P} \leftarrow p_1 \Vert p_2 \Vert \dots \Vert
            p_{j-1} \Vert \left(m, l_p, v'\right) \Vert p_{j+1} \Vert \dots \Vert
            p_N$
          \EndCase

          \Case{$Greedy$}
             \State
               \Comment{If post belongs to voting ring and not reached min
               VPower}
             \If{$p \in s.R $ $\land $ $p.VPower > s.Min$}
               \State $voteValue \leftarrow p.VPower \cdot weight \cdot sp$
               \State $p \leftarrow p.votes +  voteValue$
             \EndIf
          \EndCase
        \EndSwitch

        \State \Return $\mathcal{P}$
      \EndFunction
      \end{algorithmic}
    \end{algorithm}
    TODOS\footnote{TODO: Improve argmax notation}\fnmsep\footnote{TODO: Write Greedy}

    \begin{algorithm}[H]
      \caption{Players cast votes for $r$ rounds}
      \label{alg:curation}
      \begin{algorithmic}[1]
      \Function{Curate}{$\mathcal{U}, \mathcal{P}, r$}
        \For{$j = 1$ to $r$}
          \Comment{$r$ voting rounds}
          \For {$u_i \in \mathcal{U}$}
            \If{\textsc{IsVoteRound}$\left(j, S_i, r, N\right)$}
              \State $\mathcal{P} \leftarrow \textsc{Vote}\left(u_i,
              \mathcal{P}\right)$
                \Comment{Player $i$ votes zero or one posts}
            \EndIf
          \EndFor
          \State $\mathcal{P} \leftarrow \textsc{Order}\left(\mathcal{P}\right)$
            \Comment{Order posts by vote count after each round of votes}
        \EndFor
        \State \Return $\mathcal{P}$
      \EndFunction
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
      \caption{Calculates whether voting in this round is optimal}
      \label{alg:isvoteround}
      \begin{algorithmic}[1]
        \Function{IsVoteRound}{$j, S, r, N$}
          \State 
        \EndFunction
      \end{algorithmic}
    \end{algorithm}

    \begin{algorithm}[H]
      \caption{Steem$\left(\mathcal{U}, \mathcal{P}, r\right)$}
      \label{alg:main}
      \begin{algorithmic}[1]
      \State $\mathcal{P} \leftarrow \textsc{Curate}\left(\mathcal{U},
      \mathcal{P}, r\right)$
      \State \Return $\mathcal{P}$
      \end{algorithmic}
    \end{algorithm}
